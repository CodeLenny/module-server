// Generated by CoffeeScript 1.11.1
var ModuleServer, ModuleTest, Promise, TestDesc, TestRun, after, before, blade, bodyParser, chalk, coffee, describe, exec, express, getPort, it, net, phantom, ref,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Promise = require("bluebird");

net = require("net");

blade = require("blade");

coffee = require("coffee-script");

express = require("express");

bodyParser = require("body-parser");

phantom = require("phantom");

ModuleServer = require("./ModuleServer");

ref = require("mocha"), describe = ref.describe, it = ref.it, before = ref.before, after = ref.after;

exec = require("child_process").exec;

chalk = require("chalk");

TestDesc = require("./TestDesc");

TestRun = require("./TestRun");


/*
Picks random high ports in (hopefully) free teritory.
@param {Integer} min **Optional** the smalllest port to choose.  Defaults to `49152`.
@param {Integer} max **Optional** the largest port to choose.  Defaults to `65535`.
@param {Function} cb Called with the free port.
 */

getPort = function(min, max, cb) {
  if (min == null) {
    min = 49152;
  }
  if (max == null) {
    max = 65535;
  }
  return new Promise(function(resolve, reject) {
    var port, server;
    if (typeof max === "function") {
      cb = max;
      max = 65525;
    }
    if (typeof min === "function") {
      cb = min;
      min = 49152;
    }
    port = Math.floor(Math.random() * (max - min + 1)) + min;
    server = net.createServer();
    server.once('error', function(err) {
      console.log("Port " + port + " taken.  Retrying.");
      return getPort(min, max, cb);
    });
    server.once('listening', function() {
      return server.close(function() {
        if (cb) {
          cb(port);
        }
        return resolve(port);
      });
    });
    return server.listen(port);
  });
};


/*
Sets up a [Mocha](https://mochajs.org/) testing environment for server-side components.
 */

ModuleTest = (function() {

  /*
  @property {Boolean} `true` to print more messages while running.
   */
  ModuleTest.DEBUG = false;


  /*
  @property {String} the name to give the `describe` block this test will create
  @private
   */

  ModuleTest.prototype.describeName = null;


  /*
  @property {Promise<String>} elements inside the body of the testing webpage
  @private
   */

  ModuleTest.prototype._body = null;


  /*
  @property {Array<TestDesc>} tests to run
  @private
   */

  ModuleTest.prototype._tests = null;


  /*
  @property {Object<String, String>} module `name: path` to load via ModuleServer.
   */

  ModuleTest.prototype._load = null;


  /*
  @property {Function<Connect>} a function that returns a [Connect](http://senchalabs.github.com/connect) server.
   */

  ModuleTest.prototype._server = null;


  /*
  @property {Boolean} `true` to only run this test.
   */

  ModuleTest.prototype._only = null;


  /*
  @property {Boolean} `true` to skip this test.
   */

  ModuleTest.prototype._skip = null;


  /*
  @property {PhantomJS.Instance} A pointer to the PhantomJS instance.
   */

  ModuleTest.prototype._phantomInstance = null;


  /*
  @property {PhantomJS.Page} A pointer to the PhantomJS page.
   */

  ModuleTest.prototype._phantomPage = null;


  /*
  Initializes a new testing environment for a series of tests (`it` blocks) inside a single
  `describe` block.
  @param {String} describeName a name to use for the `describe` block.
   */

  function ModuleTest(describeName) {
    this.describeName = describeName;
    this._listenCloseTestScript = bind(this._listenCloseTestScript, this);
    this._testScript = bind(this._testScript, this);
    this._index = bind(this._index, this);
    this._load = {
      TestResponse: __dirname + "/../test-response/"
    };
    this._tests = [];
  }


  /*
  Allows a custom Connect server to be used.  Must not be assigned a port.
  @property {Function<Connect>} _server a function to generate a new Connect server.  Can optionally return an array
    with both `Connect` and an existing `ModuleServer`.
   */

  ModuleTest.prototype.server = function(_server) {
    this._server = _server;
    return this;
  };


  /*
  Passes load arguments to ModuleServer.
  @param {String} name module name to provide to the client
  @param {String} path location of module source files
  @see {ModuleServer.load}
  @return {ModuleTest}
   */

  ModuleTest.prototype.load = function(name, path) {
    this._load[name] = path;
    return this;
  };


  /*
  Determines the elements to include inside the body of the testing webpage.
  @param {String} str [blade](https://github.com/bminer/node-blade) formatted text to include
  @return {ModuleServer}
   */

  ModuleTest.prototype.blade = function(str) {
    if (!str || str === "") {
      this._body = Promise.resolve("");
      return this;
    }
    this._body = new Promise(function(resolve, reject) {
      return blade.compile(str, function(err, tmpl) {
        if (err) {
          reject(err);
        }
        return tmpl({}, function(err, html) {
          if (err) {
            reject(err);
          }
          return resolve(html);
        });
      });
    });
    return this;
  };


  /*
  Determines the elements to include inside the body of the testing webpage.
  @param {String} str HTML elements to include
  @return {ModuleTest}
   */

  ModuleTest.prototype.html = function(str) {
    this._body = str;
    return this;
  };


  /*
  Determines [RequireJS](http://requirejs.org/)-based code to run tests.
  @param {String} src [CoffeeScript](http://coffeescript.org/) formatted source to use
  @return {ModuleTest}
   */

  ModuleTest.prototype.coffee = function(src) {
    this._js = coffee.compile(src, {
      bare: true
    });
    return this;
  };


  /*
  Determines [RequireJS](http://requirejs.org/)-based code to run tests.
  @param {String} src JavaScript formatted source to use
  @return {ModuleTest}
   */

  ModuleTest.prototype.js = function(src) {
    return this._js = src;
  };


  /*
  Provides a test that will be triggered by client calls to `TestResponse.emit`.
  @param {String} name the name to give to [Mocha](https://mochajs.org/)'s `it`
  @param {String} handler the event that will be called by `TestResponse.emit`
  @param {Integer} timeout **Optional** changes [Mocha](https://mochajs.org/)'s timeout.  Defaults to 2000ms.
  @param {Function} cb called with the data given to `TestResponse.emit`, to provide chai testing.
  @return {ModuleTest}
   */

  ModuleTest.prototype.onit = function(name, handler, timeout, cb) {
    this._tests.push(new TestDesc(name, handler, timeout, cb));
    return this;
  };


  /*
  Listens to a handler.  Returns an object containing a method to define tests.
  @param {String} Handler
  @return {ModuleTest}
  @example Define a test
    test
      .on("divCount")
      .it "has 10 divs", 5000, (divCount) -> divCount.should.equal 10
   */

  ModuleTest.prototype.on = function(handler) {
    var res;
    res = {};
    return res.it = (function(_this) {
      return function(name, timeout, cb) {
        _this.onit(name, handler, timeout, cb);
        return _this;
      };
    })(this);
  };


  /*
  Only run this ModuleTest.  Uses `describe.only(...)` in Mocha.
  @return {ModuleTest}
   */

  ModuleTest.prototype.only = function() {
    this._only = true;
    return this;
  };


  /*
  Skip this ModuleTest.  Uses `describe.skip(...)` in Mocha.
  @return {ModuleTest}
   */

  ModuleTest.prototype.skip = function() {
    this._skip = true;
    return this;
  };


  /*
  Starts a [Phantom](https://github.com/amir20/phantomjs-node) browser, and visits the index
  page at the server given.
  @param {Integer} port the port a server is listening on
  @return {Promise<Array<Phantom.create(), Phantom.create().open()>>}
  @private
   */

  ModuleTest.prototype.startPhantom = function(port) {
    var instance, page;
    page = null;
    instance = null;
    return phantom.create().then(function(i) {
      instance = i;
      return instance.createPage();
    }).then(function(p) {
      page = p;
      page.on('onError', function(err) {
        if (!ModuleTest.DEBUG) {
          return;
        }
        console.log(chalk.red.bold("Page experienced error"));
        console.log(err);
        return console.log("\n");
      });
      page.on('onConsoleMessage', function(msg) {
        if (!ModuleTest.DEBUG) {
          return;
        }
        console.log(chalk.blue.bold("Page Logged:"));
        return console.log(chalk.dim.blue("  " + msg.replace("\n", "  \n")));
      });
      return page.open("http://localhost:" + port + "/codelenny-module-server/");
    }).then(function(content) {
      if (ModuleTest.DEBUG) {
        return console.log(content);
      }
    })["catch"](function(err) {
      return console.log("Error: " + err);
    }).then(function() {
      return [instance, page];
    });
  };


  /*
  Express route to fetch the index page for a server.
  @param {Express.req} req details about the request
  @param {Express.res} res our response to the user
  @private
   */

  ModuleTest.prototype._index = function(req, res) {
    if (!this._body) {
      this._body = "";
      return console.log("No HTML given, defaulting to an empty body");
    }
    return Promise.resolve(this._body).then(function(body) {
      return res.send("<!DOCTYPE html>\n<html>\n  <body>\n    " + body + "\n    <script data-main=\"/codelenny-module-server/test.js\" src=\"/requirejs/\"></script>\n  </body>\n</html>");
    })["catch"](function(err) {
      return console.log("Error resolving body: " + err);
    });
  };


  /*
  Express route to fetch the [RequireJS](http://requirejs.org/)-based test runner.
  @param {Express.req} req details about the request
  @param {Express.res} res our response to the user
  @private
   */

  ModuleTest.prototype._testScript = function(req, res) {
    if (!this._js) {
      res.send("");
      return console.log("No JavaScript!");
    }
    return res.send("define(\"clienttest\", function(require) {\n  " + this._js + "\n});\ndefine([\"/modules/ModuleConfig.js\"], function (ModuleConfig) {\n  new ModuleConfig(function() {\n    require([\"clienttest\"], function(clienttest) {});\n  });\n});");
  };


  /*
  Express route to fetch the [RequireJS](http://requirejs.org/)-based test runner,
  and listen for the close event at the same time.
  @param {Express.req} req details about the request
  @param {Express.res} res our response to the user
  @private
   */

  ModuleTest.prototype._listenCloseTestScript = function(req, res) {
    if (!this._js) {
      res.send("");
      return console.log("No JavaScript!");
    }
    return res.send("define(\"clienttest\", function(require) {\n  " + this._js + "\n  $jq = require(\"jquery\");\n  $jq(window).on(\"unload\", function() {\n    $jq.ajaxSetup({async: false});\n    $jq.get(\"/moduletest/unload/\");\n  });\n});\ndefine([\"/modules/ModuleConfig.js\"], function (ModuleConfig) {\n  new ModuleConfig(function() {\n    require([\"clienttest\"], function(clienttest) {});\n  });\n});");
  };


  /*
  Creates a [Connect](http://senchalabs.github.com/connect) server, using {ModuleTest#_server} if avalible, otherwise
  creating a new Express server.  Provides basic routing for tests, and loads the required modules.
   */

  ModuleTest.prototype._createServer = function() {
    var moduleServer, name, path, ref1, ref2, router;
    router = this._server ? this._server() : express();
    if (Array.isArray(router)) {
      ref1 = router, router = ref1[0], moduleServer = ref1[1];
    }
    router.get("/codelenny-module-server/", this._index);
    router.get("/codelenny-module-server/test.js", this._testScript);
    if (moduleServer == null) {
      moduleServer = new ModuleServer(router, "/module/", "/modules/ModuleConfig.js");
    }
    ref2 = this._load;
    for (name in ref2) {
      path = ref2[name];
      moduleServer.load(name, path);
    }
    moduleServer.finalize();
    return router;
  };


  /*
  Returns the correct `describe`/`describe.only`/`describe.skip` depending on user input.
  Also allows adding hooks.
  @return {Mocha.describe}
   */

  ModuleTest.prototype._runner = function() {
    var runner;
    runner = describe;
    if (this._only) {
      runner = describe.only;
    } else if (this._skip) {
      runner = describe.skip;
    }
    return runner;
  };


  /*
  Runs the given tests in a [Mocha](https://mochajs.org/) `describe` block the given number of times.
  @param {Integer} count **Optional** the number of times to run the tests.  Defaults to `1`.
  @return {ModuleTest}
   */

  ModuleTest.prototype.run = function(count) {
    var fn, i, j, ref1;
    if (count == null) {
      count = 1;
    }
    fn = (function(_this) {
      return function(i, count) {
        var name;
        name = count === 1 ? _this.describeName : _this.describeName + " (run " + i + "/" + count + ")";
        return _this._runner()(name, function() {
          var done, phantomInstance, phantomPage, ref2, server, started, test, tests;
          ref2 = [], server = ref2[0], phantomInstance = ref2[1], phantomPage = ref2[2];
          tests = (function() {
            var k, len, ref3, results;
            ref3 = this._tests;
            results = [];
            for (k = 0, len = ref3.length; k < len; k++) {
              test = ref3[k];
              results.push(new TestRun(test));
            }
            return results;
          }).call(_this);
          started = (function() {
            var k, len, results;
            results = [];
            for (k = 0, len = tests.length; k < len; k++) {
              test = tests[k];
              results.push(test.started);
            }
            return results;
          })();
          done = (function() {
            var k, len, results;
            results = [];
            for (k = 0, len = tests.length; k < len; k++) {
              test = tests[k];
              results.push(test.done.reflect());
            }
            return results;
          })();
          Promise.any(started).then(function(test) {
            test.timeout(test.timeout() + 1500);
            return test.slow(1500);
          }).then(function() {
            return getPort();
          }).then(function(port) {
            var router;
            router = _this._createServer();
            return Promise.map(tests, function(test) {
              return test.route(router);
            }).then(function() {
              return [port, router];
            });
          }).then(function(arg) {
            var port, router;
            port = arg[0], router = arg[1];

            /*
            log = (stack, indent='') ->
              for val in stack
                if val.route
                  console.log indent + val.route.path
                else if val.regexp
                  console.log indent + val.regexp
                else console.log val
                log val.route.stack, "#{indent}  " if val.route?.stack
                log val.handle.stack, "#{indent}  " if val.handle?.stack
            log router._router.stack
             */
            server = router.listen(port);
            return _this.startPhantom(port);
          }).then(function(res) {
            phantomInstance = res[0], phantomPage = res[1];
            _this._phantomInstance = phantomInstance;
            return _this._phantomPage = phantomPage;
          })["catch"](function(err) {
            return console.log("Error starting tests for " + name + ": " + err);
          });
          return Promise.all(done).then(function() {
            if (phantomPage) {
              phantomPage.close();
            }
            if (phantomInstance) {
              phantomInstance.exit();
            }
            if (!server) {
              return;
            }
            return new Promise(function(resolve, reject) {
              return server.close(resolve);
            });
          })["catch"](function(err) {
            console.log("Error tearing down after " + name);
            throw err;
          });
        });
      };
    })(this);
    for (i = j = 1, ref1 = count; 1 <= ref1 ? j <= ref1 : j >= ref1; i = 1 <= ref1 ? ++j : --j) {
      fn(i, count);
    }
    return this;
  };


  /*
  Starts the testing server running via a Chrome browser for manual debugging.
  Creates a fake test to keep the server alive.
  @param {Integer} timeout **Optional** the delay length to ensure that the developer tools
    have opened, in ms.  If 0, listens for page close instead.  Defaults to 10000 ms (10 seconds).
  @return {ModuleTest}
   */

  ModuleTest.prototype.chrome = function(timeout) {
    if (timeout == null) {
      timeout = 10000;
    }
    getPort((function(_this) {
      return function(port) {
        var closed, cmd, moduleServer, name, path, ref1, ref2, router, server;
        router = _this._server ? _this._server() : express();
        if (Array.isArray(router)) {
          ref1 = router, router = ref1[0], moduleServer = ref1[1];
        }
        router.get("/codelenny-module-server/", _this._index);
        closed = null;
        if (timeout === 0) {
          closed = new Promise(function(resolve, reject) {
            var _timer, close, open;
            _timer = null;
            open = function(req, res, next) {
              clearTimeout(_timer);
              return next();
            };
            close = function(req, res) {
              _timer = setTimeout(resolve, 2000);
              return res.send("");
            };
            router.get("/codelenny-module-server/test.js", open, _this._listenCloseTestScript);
            return router.get("/moduletest/unload/", close);
          });
        } else {
          router.get("/codelenny-module-server/test.js", _this._testScript);
        }
        if (moduleServer == null) {
          moduleServer = new ModuleServer(router, "/module/", "/modules/ModuleConfig.js");
        }
        ref2 = _this._load;
        for (name in ref2) {
          path = ref2[name];
          moduleServer.load(name, path);
        }
        moduleServer.finalize();
        server = router.listen(port);
        cmd = "google-chrome http://localhost:" + port + "/codelenny-module-server/";
        exec(cmd);
        if (ModuleTest.DEBUG) {
          console.log(cmd);
        }
        return describe("Developer Tools for " + _this.describeName, function() {
          return it("Opens Developer Tools", function(done) {
            if (timeout === 0) {
              this.timeout(0);
              closed.then(done);
              return true;
            } else {
              this.timeout(timeout + 500);
              return setTimeout(done, timeout);
            }
          });
        });
      };
    })(this));
    return this;
  };

  return ModuleTest;

})();

module.exports = ModuleTest;

//# sourceMappingURL=ModuleTest.js.map
