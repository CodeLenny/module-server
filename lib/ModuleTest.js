// Generated by CoffeeScript 1.10.0
var ModuleServer, ModuleTest, after, before, blade, bodyParser, coffee, describe, exec, express, getPort, it, net, phantom, ref,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

net = require("net");

blade = require("blade");

coffee = require("coffee-script");

express = require("express");

bodyParser = require("body-parser");

phantom = require("phantom");

ModuleServer = require("./ModuleServer");

ref = require("mocha"), describe = ref.describe, it = ref.it, before = ref.before, after = ref.after;

exec = require("child_process").exec;


/*
Picks random high ports in (hopefully) free teritory.
@param {Integer} min **Optional** the smalllest port to choose.  Defaults to `49152`.
@param {Integer} max **Optional** the largest port to choose.  Defaults to `65535`.
@param {Function} cb Called with the free port.
 */

getPort = function(min, max, cb) {
  var port, server;
  if (min == null) {
    min = 49152;
  }
  if (max == null) {
    max = 65535;
  }
  if (typeof max === "function") {
    cb = max;
    max = 65525;
  }
  if (typeof min === "function") {
    cb = min;
    min = 49152;
  }
  port = Math.floor(Math.random() * (max - min + 1)) + min;
  server = net.createServer();
  server.once('error', function(err) {
    console.log("Port " + port + " taken.  Retrying.");
    return getPort(min, max, cb);
  });
  server.once('listening', function() {
    server.close();
    if (cb) {
      return cb(port);
    }
  });
  return server.listen(port);
};


/*
Sets up a [Mocha](https://mochajs.org/) testing environment for server-side components.
 */

ModuleTest = (function() {

  /*
  @property {Boolean} `true` to print more messages while running.
   */
  ModuleTest.DEBUG = false;


  /*
  @property {String} the name to give the `describe` block this test will create
  @private
   */

  ModuleTest.prototype.describeName = null;


  /*
  @property {Promise<String>} elements inside the body of the testing webpage
  @private
   */

  ModuleTest.prototype._body = null;


  /*
  @property {Array<Function>} functions that will create an `it` test run.
  @private
   */

  ModuleTest.prototype._it = null;


  /*
  @property {Object<String, String>} module `name: path` to load via ModuleServer.
   */

  ModuleTest.prototype._load = null;


  /*
  Initializes a new testing environment for a series of tests (`it` blocks) inside a single
  `describe` block.
  @param {String} describeName a name to use for the `describe` block.
   */

  function ModuleTest(describeName) {
    this.describeName = describeName;
    this._testScript = bind(this._testScript, this);
    this._index = bind(this._index, this);
    this._load = {
      TestResponse: __dirname + "/../test-response/"
    };
    this._it = [];
  }


  /*
  Passes load arguments to ModuleServer.
  @param {String} name module name to provide to the client
  @param {String} path location of module source files
  @see {ModuleServer.load}
  @return {ModuleTest}
   */

  ModuleTest.prototype.load = function(name, path) {
    this._load[name] = path;
    return this;
  };


  /*
  Determines the elements to include inside the body of the testing webpage.
  @param {String} str [blade](https://github.com/bminer/node-blade) formatted text to include
  @return {ModuleServer}
   */

  ModuleTest.prototype.blade = function(str) {
    if (!str || str === "") {
      this._body = Promise.resolve("");
      return this;
    }
    this._body = new Promise(function(resolve, reject) {
      return blade.compile(str, function(err, tmpl) {
        if (err) {
          reject(err);
        }
        return tmpl({}, function(err, html) {
          if (err) {
            reject(err);
          }
          return resolve(html);
        });
      });
    });
    return this;
  };


  /*
  Determines the elements to include inside the body of the testing webpage.
  @param {String} str HTML elements to include
  @return {ModuleTest}
   */

  ModuleTest.prototype.html = function(str) {
    this._body = Promise.resolve(str);
    return this;
  };


  /*
  Determines [RequireJS](http://requirejs.org/)-based code to run tests.
  @param {String} src [CoffeeScript](http://coffeescript.org/) formatted source to use
  @return {ModuleTest}
   */

  ModuleTest.prototype.coffee = function(src) {
    this._js = coffee.compile(src, {
      bare: true
    });
    return this;
  };


  /*
  Determines [RequireJS](http://requirejs.org/)-based code to run tests.
  @param {String} src JavaScript formatted source to use
  @return {ModuleTest}
   */

  ModuleTest.prototype.js = function(src) {
    return this._js = src;
  };


  /*
  Provides a test that will be triggered by client calls to `TestResponse.emit`.
  @param {String} name the name to give to [Mocha](https://mochajs.org/)'s `it`
  @param {String} handler the event that will be called by `TestResponse.emit`
  @param {Integer} timeout **Optional** changes [Mocha](https://mochajs.org/)'s timeout.  Defaults to 2000ms.
  @param {Function} cb called with the data given to `TestResponse.emit`, to provide chai testing.
  @return {ModuleTest}
   */

  ModuleTest.prototype.onit = function(name, handler, timeout, cb) {
    if (!cb) {
      cb = timeout;
      timeout = 2000;
    }
    this._it.push((function(_this) {
      return function(router, started) {
        var args;
        args = new Promise(function(resolve, reject) {
          router.post("/testresponse/" + handler + "/", bodyParser.urlencoded({
            extended: true
          }), function(req, res) {
            if (ModuleTest.DEBUG) {
              console.log("Got " + req.body.args);
            }
            return resolve(req.body.args);
          });
          return started();
        });
        return it(name, function() {
          this.timeout(timeout);
          return args.then(function(args) {
            if (cb) {
              return cb.apply(null, args);
            }
          });
        });
      };
    })(this));
    return this;
  };


  /*
  Starts a [Phantom](https://github.com/amir20/phantomjs-node) browser, and visits the index
  page at the server given.
  @param {Integer} port the port a server is listening on
  @return {Promise<Array<Phantom.create(), Phantom.create().open()>>}
  @private
   */

  ModuleTest.prototype.startPhantom = function(port) {
    var instance, page;
    page = null;
    instance = null;
    return phantom.create().then(function(i) {
      instance = i;
      return instance.createPage();
    }).then(function(p) {
      page = p;
      page.property('onError', function(msg) {
        if (ModuleTest.DEBUG) {
          return console.log("Page experienced error: " + msg);
        }
      });
      page.property('onConsoleMessage', function(msg) {
        if (ModuleTest.DEBUG) {
          return console.log("Page logged: " + msg);
        }
      });
      return page.open("http://localhost:" + port + "/");
    }).then(function(content) {
      if (ModuleTest.DEBUG) {
        return console.log(content);
      }
    })["catch"](function(err) {
      return console.log("Error: " + err);
    }).then(function() {
      return [instance, page];
    });
  };


  /*
  Express route to fetch the index page for a server.
  @param {Express.req} req details about the request
  @param {Express.res} res our response to the user
  @private
   */

  ModuleTest.prototype._index = function(req, res) {
    if (!this._body) {
      res.send("");
      return console.log("No HTML!");
    }
    return Promise.resolve(this._body).then(function(body) {
      return res.send("<!DOCTYPE html>\n<html>\n  <body>\n    " + body + "\n    <script data-main=\"/test.js\" src=\"/requirejs/\"></script>\n  </body>\n</html>");
    })["catch"](function(err) {
      return console.log("Error resolving body: " + err);
    });
  };


  /*
  Express route to fetch the [RequireJS](http://requirejs.org/)-based test runner.
  @param {Express.req} req details about the request
  @param {Express.res} res our response to the user
  @private
   */

  ModuleTest.prototype._testScript = function(req, res) {
    if (!this._js) {
      res.send("");
      return console.log("No JavaScript!");
    }
    return res.send("define(\"clienttest\", function(require) {\n  " + this._js + "\n});\ndefine([\"/modules/ModuleConfig.js\"], function (ModuleConfig) {\n  new ModuleConfig(function() {\n    require([\"clienttest\"], function(clienttest) {});\n  });\n});");
  };


  /*
  Runs the given tests in a [Mocha](https://mochajs.org/) `describe` block the given number of times.
  @param {Integer} count **Optional** the number of times to run the tests.  Defaults to `1`.
  @return {ModuleTest}
   */

  ModuleTest.prototype.run = function(count) {
    var fn, i, j, ref1;
    if (count == null) {
      count = 1;
    }
    fn = (function(_this) {
      return function(i, count) {
        return getPort(function(port) {
          var name;
          name = count === 1 ? _this.describeName : _this.describeName + " (run " + i + "/" + count + ")";
          return describe(name, function() {
            var _it, _started, k, len, moduleServer, onStart, path, ref2, ref3, results, ret, router, server;
            router = express();
            router.get("/", _this._index);
            router.get("/test.js", _this._testScript);
            moduleServer = new ModuleServer(router, "/module/", "/modules/ModuleConfig.js");
            ref2 = _this._load;
            for (name in ref2) {
              path = ref2[name];
              moduleServer.load(name, path);
            }
            ret = false;
            server = router.listen(port);
            _started = 0;
            onStart = function() {
              if (++_started === _this._it.length) {
                return _this.startPhantom(port).then(function(res) {
                  var phantomInstance, phantomPage;
                  return phantomInstance = res[0], phantomPage = res[1], res;
                });
              }
            };
            after(function() {
              if (server) {
                server.close();
              }
              if (typeof phantomPage !== "undefined" && phantomPage !== null) {
                phantomPage.close();
              }
              if (typeof phantomInstance !== "undefined" && phantomInstance !== null) {
                return phantomInstance.exit();
              }
            });
            ref3 = _this._it;
            results = [];
            for (k = 0, len = ref3.length; k < len; k++) {
              _it = ref3[k];
              results.push(_it(router, onStart));
            }
            return results;
          });
        });
      };
    })(this);
    for (i = j = 1, ref1 = count; 1 <= ref1 ? j <= ref1 : j >= ref1; i = 1 <= ref1 ? ++j : --j) {
      fn(i, count);
    }
    return this;
  };


  /*
  Starts the testing server running via a Chrome browser for manual debugging.
  @return {ModuleTest}
   */

  ModuleTest.prototype.chrome = function() {
    getPort((function(_this) {
      return function(port) {
        var moduleServer, name, path, ref1, router, server;
        router = express();
        router.get("/", _this._index);
        router.get("/test.js", _this._testScript);
        moduleServer = new ModuleServer(router, "/module/", "/modules/ModuleConfig.js");
        ref1 = _this._load;
        for (name in ref1) {
          path = ref1[name];
          moduleServer.load(name, path);
        }
        server = router.listen(port);
        return exec("google-chrome http://localhost:" + port + "/");
      };
    })(this));
    return this;
  };

  return ModuleTest;

})();

module.exports = ModuleTest;

//# sourceMappingURL=ModuleTest.js.map
